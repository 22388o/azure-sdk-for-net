// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Communication;
using Azure.Core.Pipeline;

namespace Azure.Communication.CallingServer
{
    /// <summary> The ServerCalls service client. </summary>
    public partial class ServerCallsClient
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal ServerCallsRestClient RestClient { get; }

        /// <summary> Initializes a new instance of ServerCallsClient for mocking. </summary>
        protected ServerCallsClient()
        {
        }

        /// <summary> Initializes a new instance of ServerCallsClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> The endpoint of the Azure Communication resource. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal ServerCallsClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string endpoint, string apiVersion = "2021-11-15-preview")
        {
            RestClient = new ServerCallsRestClient(clientDiagnostics, pipeline, endpoint, apiVersion);
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        /// <summary> Get participants from a server call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IReadOnlyList<CallParticipantInternal>>> GetParticipantsAsync(CallLocatorModel callLocator, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetParticipants");
            scope.Start();
            try
            {
                return await RestClient.GetParticipantsAsync(callLocator, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get participants from a server call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IReadOnlyList<CallParticipantInternal>> GetParticipants(CallLocatorModel callLocator, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetParticipants");
            scope.Start();
            try
            {
                return RestClient.GetParticipants(callLocator, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a participant to the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="participant"> The participant to be added to the call. </param>
        /// <param name="alternateCallerId"> The alternate identity of source participant. </param>
        /// <param name="operationContext"> The operation context. </param>
        /// <param name="callbackUri"> The callback URI. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<AddParticipantResult>> AddParticipantAsync(CallLocatorModel callLocator, CommunicationIdentifierModel participant, PhoneNumberIdentifierModel alternateCallerId = null, string operationContext = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.AddParticipant");
            scope.Start();
            try
            {
                return await RestClient.AddParticipantAsync(callLocator, participant, alternateCallerId, operationContext, callbackUri, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a participant to the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="participant"> The participant to be added to the call. </param>
        /// <param name="alternateCallerId"> The alternate identity of source participant. </param>
        /// <param name="operationContext"> The operation context. </param>
        /// <param name="callbackUri"> The callback URI. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<AddParticipantResult> AddParticipant(CallLocatorModel callLocator, CommunicationIdentifierModel participant, PhoneNumberIdentifierModel alternateCallerId = null, string operationContext = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.AddParticipant");
            scope.Start();
            try
            {
                return RestClient.AddParticipant(callLocator, participant, alternateCallerId, operationContext, callbackUri, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove participant from the call using identifier. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant to be removed from the call. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> RemoveParticipantAsync(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RemoveParticipant");
            scope.Start();
            try
            {
                return await RestClient.RemoveParticipantAsync(callLocator, identifier, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Remove participant from the call using identifier. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant to be removed from the call. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response RemoveParticipant(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RemoveParticipant");
            scope.Start();
            try
            {
                return RestClient.RemoveParticipant(callLocator, identifier, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get participant from the call using identifier. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IReadOnlyList<CallParticipantInternal>>> GetParticipantAsync(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetParticipant");
            scope.Start();
            try
            {
                return await RestClient.GetParticipantAsync(callLocator, identifier, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get participant from the call using identifier. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IReadOnlyList<CallParticipantInternal>> GetParticipant(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetParticipant");
            scope.Start();
            try
            {
                return RestClient.GetParticipant(callLocator, identifier, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Play audio to a participant. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant to play audio to. </param>
        /// <param name="audioFileUri">
        /// The media resource uri of the play audio request.
        /// 
        /// Currently only Wave file (.wav) format audio prompts are supported.
        /// 
        /// More specifically, the audio content in the wave file must be mono (single-channel),
        /// 
        /// 16-bit samples with a 16,000 (16KHz) sampling rate.
        /// </param>
        /// <param name="loop"> The flag indicating whether audio file needs to be played in loop or not. </param>
        /// <param name="operationContext"> The value to identify context of the operation. </param>
        /// <param name="audioFileId"> An id for the media in the AudioFileUri, using which we cache the media resource. </param>
        /// <param name="callbackUri"> The callback Uri to receive PlayAudio status notifications. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<PlayAudioResult>> ParticipantPlayAudioAsync(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, string audioFileUri, bool loop, string operationContext = null, string audioFileId = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.ParticipantPlayAudio");
            scope.Start();
            try
            {
                return await RestClient.ParticipantPlayAudioAsync(callLocator, identifier, audioFileUri, loop, operationContext, audioFileId, callbackUri, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Play audio to a participant. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant to play audio to. </param>
        /// <param name="audioFileUri">
        /// The media resource uri of the play audio request.
        /// 
        /// Currently only Wave file (.wav) format audio prompts are supported.
        /// 
        /// More specifically, the audio content in the wave file must be mono (single-channel),
        /// 
        /// 16-bit samples with a 16,000 (16KHz) sampling rate.
        /// </param>
        /// <param name="loop"> The flag indicating whether audio file needs to be played in loop or not. </param>
        /// <param name="operationContext"> The value to identify context of the operation. </param>
        /// <param name="audioFileId"> An id for the media in the AudioFileUri, using which we cache the media resource. </param>
        /// <param name="callbackUri"> The callback Uri to receive PlayAudio status notifications. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<PlayAudioResult> ParticipantPlayAudio(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, string audioFileUri, bool loop, string operationContext = null, string audioFileId = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.ParticipantPlayAudio");
            scope.Start();
            try
            {
                return RestClient.ParticipantPlayAudio(callLocator, identifier, audioFileUri, loop, operationContext, audioFileId, callbackUri, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> cancel media operation for a participant. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant. </param>
        /// <param name="mediaOperationId"> The operationId of the media operation to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelParticipantMediaOperationAsync(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, string mediaOperationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.CancelParticipantMediaOperation");
            scope.Start();
            try
            {
                return await RestClient.CancelParticipantMediaOperationAsync(callLocator, identifier, mediaOperationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> cancel media operation for a participant. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="identifier"> The identifier of the participant. </param>
        /// <param name="mediaOperationId"> The operationId of the media operation to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelParticipantMediaOperation(CallLocatorModel callLocator, CommunicationIdentifierModel identifier, string mediaOperationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.CancelParticipantMediaOperation");
            scope.Start();
            try
            {
                return RestClient.CancelParticipantMediaOperation(callLocator, identifier, mediaOperationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start recording the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="recordingStateCallbackUri"> The uri to send notifications to. </param>
        /// <param name="recordingContentType"> The content type of call recording. </param>
        /// <param name="recordingChannelType"> The channel type of call recording. </param>
        /// <param name="recordingFormatType"> The format type of call recording. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<StartCallRecordingResult>> StartRecordingAsync(CallLocatorModel callLocator, string recordingStateCallbackUri = null, RecordingContentType? recordingContentType = null, RecordingChannelType? recordingChannelType = null, RecordingFormatType? recordingFormatType = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.StartRecording");
            scope.Start();
            try
            {
                return await RestClient.StartRecordingAsync(callLocator, recordingStateCallbackUri, recordingContentType, recordingChannelType, recordingFormatType, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start recording the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="recordingStateCallbackUri"> The uri to send notifications to. </param>
        /// <param name="recordingContentType"> The content type of call recording. </param>
        /// <param name="recordingChannelType"> The channel type of call recording. </param>
        /// <param name="recordingFormatType"> The format type of call recording. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<StartCallRecordingResult> StartRecording(CallLocatorModel callLocator, string recordingStateCallbackUri = null, RecordingContentType? recordingContentType = null, RecordingChannelType? recordingChannelType = null, RecordingFormatType? recordingFormatType = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.StartRecording");
            scope.Start();
            try
            {
                return RestClient.StartRecording(callLocator, recordingStateCallbackUri, recordingContentType, recordingChannelType, recordingFormatType, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get call recording properties. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<CallRecordingProperties>> GetRecordingPropertiesAsync(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetRecordingProperties");
            scope.Start();
            try
            {
                return await RestClient.GetRecordingPropertiesAsync(recordingId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get call recording properties. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<CallRecordingProperties> GetRecordingProperties(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.GetRecordingProperties");
            scope.Start();
            try
            {
                return RestClient.GetRecordingProperties(recordingId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stop recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> StopRecordingAsync(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.StopRecording");
            scope.Start();
            try
            {
                return await RestClient.StopRecordingAsync(recordingId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stop recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response StopRecording(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.StopRecording");
            scope.Start();
            try
            {
                return RestClient.StopRecording(recordingId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Pause recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> PauseRecordingAsync(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.PauseRecording");
            scope.Start();
            try
            {
                return await RestClient.PauseRecordingAsync(recordingId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Pause recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response PauseRecording(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.PauseRecording");
            scope.Start();
            try
            {
                return RestClient.PauseRecording(recordingId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resume recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> ResumeRecordingAsync(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.ResumeRecording");
            scope.Start();
            try
            {
                return await RestClient.ResumeRecordingAsync(recordingId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Resume recording the call. </summary>
        /// <param name="recordingId"> The recording id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response ResumeRecording(string recordingId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.ResumeRecording");
            scope.Start();
            try
            {
                return RestClient.ResumeRecording(recordingId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Join a call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="source"> The source of the call. </param>
        /// <param name="callbackUri"> The callback URI. </param>
        /// <param name="subject"> The subject. </param>
        /// <param name="requestedMediaTypes"> The requested modalities. </param>
        /// <param name="requestedCallEvents"> The requested call events to subscribe to. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<JoinCallResultInternal>> JoinCallAsync(CallLocatorModel callLocator, CommunicationIdentifierModel source, string callbackUri, string subject = null, IEnumerable<CallMediaType> requestedMediaTypes = null, IEnumerable<CallingEventSubscriptionType> requestedCallEvents = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.JoinCall");
            scope.Start();
            try
            {
                return await RestClient.JoinCallAsync(callLocator, source, callbackUri, subject, requestedMediaTypes, requestedCallEvents, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Join a call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="source"> The source of the call. </param>
        /// <param name="callbackUri"> The callback URI. </param>
        /// <param name="subject"> The subject. </param>
        /// <param name="requestedMediaTypes"> The requested modalities. </param>
        /// <param name="requestedCallEvents"> The requested call events to subscribe to. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<JoinCallResultInternal> JoinCall(CallLocatorModel callLocator, CommunicationIdentifierModel source, string callbackUri, string subject = null, IEnumerable<CallMediaType> requestedMediaTypes = null, IEnumerable<CallingEventSubscriptionType> requestedCallEvents = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.JoinCall");
            scope.Start();
            try
            {
                return RestClient.JoinCall(callLocator, source, callbackUri, subject, requestedMediaTypes, requestedCallEvents, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Play audio in the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="audioFileUri">
        /// The media resource uri of the play audio request.
        /// 
        /// Currently only Wave file (.wav) format audio prompts are supported.
        /// 
        /// More specifically, the audio content in the wave file must be mono (single-channel),
        /// 
        /// 16-bit samples with a 16,000 (16KHz) sampling rate.
        /// </param>
        /// <param name="loop"> The flag indicating whether audio file needs to be played in loop or not. </param>
        /// <param name="operationContext"> The value to identify context of the operation. </param>
        /// <param name="audioFileId"> An id for the media in the AudioFileUri, using which we cache the media resource. </param>
        /// <param name="callbackUri"> The callback Uri to receive PlayAudio status notifications. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<PlayAudioResult>> PlayAudioAsync(CallLocatorModel callLocator, string audioFileUri, bool loop, string operationContext = null, string audioFileId = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.PlayAudio");
            scope.Start();
            try
            {
                return await RestClient.PlayAudioAsync(callLocator, audioFileUri, loop, operationContext, audioFileId, callbackUri, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Play audio in the call. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="audioFileUri">
        /// The media resource uri of the play audio request.
        /// 
        /// Currently only Wave file (.wav) format audio prompts are supported.
        /// 
        /// More specifically, the audio content in the wave file must be mono (single-channel),
        /// 
        /// 16-bit samples with a 16,000 (16KHz) sampling rate.
        /// </param>
        /// <param name="loop"> The flag indicating whether audio file needs to be played in loop or not. </param>
        /// <param name="operationContext"> The value to identify context of the operation. </param>
        /// <param name="audioFileId"> An id for the media in the AudioFileUri, using which we cache the media resource. </param>
        /// <param name="callbackUri"> The callback Uri to receive PlayAudio status notifications. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<PlayAudioResult> PlayAudio(CallLocatorModel callLocator, string audioFileUri, bool loop, string operationContext = null, string audioFileId = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.PlayAudio");
            scope.Start();
            try
            {
                return RestClient.PlayAudio(callLocator, audioFileUri, loop, operationContext, audioFileId, callbackUri, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> cancel media operation. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="mediaOperationId"> The operationId of the media operation to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelMediaOperationAsync(CallLocatorModel callLocator, string mediaOperationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.CancelMediaOperation");
            scope.Start();
            try
            {
                return await RestClient.CancelMediaOperationAsync(callLocator, mediaOperationId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> cancel media operation. </summary>
        /// <param name="callLocator"> The call locator. </param>
        /// <param name="mediaOperationId"> The operationId of the media operation to cancel. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelMediaOperation(CallLocatorModel callLocator, string mediaOperationId, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.CancelMediaOperation");
            scope.Start();
            try
            {
                return RestClient.CancelMediaOperation(callLocator, mediaOperationId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Answer the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="requestedMediaTypes"> The requested modalities. </param>
        /// <param name="requestedCallEvents"> The requested call events to subscribe to. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<AnswerCallResult>> AnswerCallAsync(string incomingCallContext, string callbackUri = null, IEnumerable<CallMediaType> requestedMediaTypes = null, IEnumerable<CallingEventSubscriptionType> requestedCallEvents = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.AnswerCall");
            scope.Start();
            try
            {
                return await RestClient.AnswerCallAsync(incomingCallContext, callbackUri, requestedMediaTypes, requestedCallEvents, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Answer the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="requestedMediaTypes"> The requested modalities. </param>
        /// <param name="requestedCallEvents"> The requested call events to subscribe to. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<AnswerCallResult> AnswerCall(string incomingCallContext, string callbackUri = null, IEnumerable<CallMediaType> requestedMediaTypes = null, IEnumerable<CallingEventSubscriptionType> requestedCallEvents = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.AnswerCall");
            scope.Start();
            try
            {
                return RestClient.AnswerCall(incomingCallContext, callbackUri, requestedMediaTypes, requestedCallEvents, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Reject the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="callRejectReason"> The rejection reason. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> RejectCallAsync(string incomingCallContext, CallRejectReason? callRejectReason = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RejectCall");
            scope.Start();
            try
            {
                return await RestClient.RejectCallAsync(incomingCallContext, callRejectReason, callbackUri, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Reject the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="callRejectReason"> The rejection reason. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response RejectCall(string incomingCallContext, CallRejectReason? callRejectReason = null, string callbackUri = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RejectCall");
            scope.Start();
            try
            {
                return RestClient.RejectCall(incomingCallContext, callRejectReason, callbackUri, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Redirect the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="targets"> The target identity to redirect the call to. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="timeoutInSeconds"> The timeout for the redirect in seconds. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> RedirectCallAsync(string incomingCallContext, IEnumerable<CommunicationIdentifierModel> targets, string callbackUri = null, int? timeoutInSeconds = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RedirectCall");
            scope.Start();
            try
            {
                return await RestClient.RedirectCallAsync(incomingCallContext, targets, callbackUri, timeoutInSeconds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Redirect the call. </summary>
        /// <param name="incomingCallContext"> The context associated with the call. </param>
        /// <param name="targets"> The target identity to redirect the call to. </param>
        /// <param name="callbackUri"> The callback uri. </param>
        /// <param name="timeoutInSeconds"> The timeout for the redirect in seconds. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response RedirectCall(string incomingCallContext, IEnumerable<CommunicationIdentifierModel> targets, string callbackUri = null, int? timeoutInSeconds = null, CancellationToken cancellationToken = default)
        {
            using var scope = _clientDiagnostics.CreateScope("ServerCallsClient.RedirectCall");
            scope.Start();
            try
            {
                return RestClient.RedirectCall(incomingCallContext, targets, callbackUri, timeoutInSeconds, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
